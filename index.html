<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Grass World + NPC from nested ZIP</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #blocker { position: absolute; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; }
        #instructions { text-align: center; color: white; font-family: Arial, sans-serif; cursor: pointer; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: white; font-size: 30px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Click to play</h1>
            <p>WASD = move · Mouse = look · ESC = release cursor</p>
        </div>
    </div>
    <div id="crosshair">+</div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import JSZip from 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';

        // ────────────────────── Basic scene setup ──────────────────────
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.Fog(0x88ccff, 10, 800);

        const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, renderer.domElement);
        document.getElementById('blocker').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => document.getElementById('blocker').style.display = 'none');
        controls.addEventListener('unlock', () => document.getElementById('blocker').style.display = 'flex');

        scene.add(controls.getObject());
        controls.getObject().position.y = 10; // eye height

        // ────────────────────── Simple movement ──────────────────────
        let move = {f:false, b:false, l:false, r:false};
        const vel = new THREE.Vector3();
        const dir = new THREE.Vector3();
        let prev = performance.now();

        onkeydown = onkeyup = e => {
            switch(e.code){
                case 'KeyW': move.f = e.type==='keydown'; break;
                case 'KeyS': move.b = e.type==='keydown'; break;
                case 'KeyA': move.l = e.type==='keydown'; break;
                case 'KeyD': move.r = e.type==='keydown'; break;
            }
        };

        // ────────────────────── Lights ──────────────────────
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.9);
        sun.position.set(100, 150, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // ─────────────────────── Grass floor ──────────────────────
        const texLoader = new THREE.TextureLoader();
        const grass = texLoader.load('Textures/Grass.png');
        grass.wrapS = grass.wrapT = THREE.RepeatWrapping;
        grass.repeat.set(300,300);
        grass.encoding = THREE.sRGBEncoding;

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(3000,3000),
            new THREE.MeshStandardMaterial({ map: grass, roughness:0.9 })
        );
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ────────────────────── LOAD NPC FROM NESTED ZIP ──────────────────────
        async function loadNestedNPC() {
            try {
                // 1. Load outer zip
                const outerResp = await fetch('Models/NPC.zip');
                const outerZip = await JSZip.loadAsync(await outerResp.arrayBuffer());

                // 2. Find and load the inner model.zip
                const innerZipFile = Object.values(outerZip.files).find(f => 
                    f.name.toLowerCase().endsWith('model.zip') || f.name.includes('model/model.zip')
                );
                if (!innerZipFile) throw 'model.zip not found inside NPC.zip';

                const innerZipData = await innerZipFile.async('arraybuffer');
                const innerZip = await JSZip.loadAsync(innerZipData);

                // 3. Create Blob URLs for every file in BOTH zips
                const urlMap = {};

                // helper to add all files from a zip
                async function addFiles(zip, prefix = '') {
                    for (const [path, file] of Object.entries(zip.files)) {
                        if (file.dir) continue;
                        const blob = await file.async('blob');
                        urlMap[prefix + path] = URL.createObjectURL(blob);
                    }
                }

                await addFiles(outerZip);           // textures folder, etc.
                await addFiles(innerZip, 'model/'); // files from inner zip appear under "model/"

                // 4. Find .mtl and .obj
                const mtlFile = Object.keys(urlMap).find(k => k.toLowerCase().endsWith('.mtl'));
                const objFile = Object.keys(urlMap).find(k => k.toLowerCase().endsWith('.obj'));

                if (!objFile) throw 'No .obj file found inside the zips';

                // 5. Custom LoadingManager that rewrites every URL to our blob URLs
                const manager = new THREE.LoadingManager();
                manager.setURLModifier(url => {
                    // Three.js sometimes gives full URLs → extract path part
                    try {
                        const u = new URL(url);
                        return urlMap[u.pathname.slice(1)] || url; // slice(1) removes leading /
                    } catch {
                        return urlMap[url] || url;
                    }
                });

                const objLoader = new OBJLoader(manager);

                if (mtlFile) {
                    const mtlLoader = new MTLLoader(manager);
                    const materials = await mtlLoader.loadAsync(urlMap[mtlFile]);
                    materials.preload();
                    objLoader.setMaterials(materials);
                }

                const obj = await objLoader.loadAsync(urlMap[objFile]);

                // Scale & position (adjust these numbers to fit your model)
                obj.scale.set(2, 2, 2);           // most free .obj characters are tiny
                obj.position.set(0, 0, -30);       // 30 meters in front of player start
                obj.rotation.y = Math.PI;         // face the player

                obj.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                scene.add(obj);
                console.log('NPC successfully loaded and placed in front of you!');

            } catch (err) {
                console.error('Could not load NPC:', err);
            }
        }

        loadNestedNPC();

        // ────────────────────── Resize & animate ──────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prev) / 1000;

                vel.x -= vel.x * 10 * delta;
                vel.z -= vel.z * 10 * delta;

                dir.z = Number(move.f) - Number(move.b);
                dir.x = Number(move.r) - Number(move.l);
                dir.normalize();

                if (move.f || move.b) vel.z -= dir.z * 400 * delta;
                if (move.l || move.r) vel.x -= dir.x * 400 * delta;

                controls.moveRight(-vel.x * delta);
                controls.moveForward(-vel.z * delta);

                controls.getObject().position.y = 10;
                prev = time;
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
